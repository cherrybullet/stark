package com.craftinginterpreters.lox;

import java.util.HashMap;            
import java.util.Map;                

class LoxInstance {                  
  private LoxClass klass;            

  LoxInstance(LoxClass klass) {      
    this.klass = klass;              
  }                                  
  @Override                          
  public String toString() {         
    return klass.name + " instance";
  }                                  
}                                    
lox/LoxInstance.java, create new file


while (true) {                             
  if (match(LEFT_PAREN)) {                 
    expr = finishCall(expr);               
  } else if (match(DOT)) {                 
    Token name = consume(IDENTIFIER,       
        "Expect property name after '.'.");
    expr = new Expr.Get(expr, name);       
  } else {                                 
    break;                                 
  }                                        
}                                          
lox/Parser.java, in call()


@Override                                
  public Void visitGetExpr(Expr.Get expr) {
    resolve(expr.object);                  
    return null;                           
  }                                        

lox/Resolver.java, add after visitCallExpr()


@Override                                        
  public Object visitGetExpr(Expr.Get expr) {      
    Object object = evaluate(expr.object);         
    if (object instanceof LoxInstance) {           
      return ((LoxInstance) object).get(expr.name);
    }

    throw new RuntimeError(expr.name,              
        "Only instances have properties.");        
  }                                                
lox/Interpreter.java, add after visitCallExpr()


private LoxClass klass;                                    
  private final Map<String, Object> fields = new HashMap<>();

  LoxInstance(LoxClass klass) {                              
lox/LoxInstance.java, in class LoxInstance



Object get(Token name) {                           
    if (fields.containsKey(name.lexeme)) {           
      return fields.get(name.lexeme);                
    }

    throw new RuntimeError(name,
        "Undefined property '" + name.lexeme + "'.");
  }                                                  
lox/LoxInstance.java, add after LoxInstance()




return new Expr.Assign(name, value);             
    } else if (expr instanceof Expr.Get) {             
      Expr.Get get = (Expr.Get)expr;                   
      return new Expr.Set(get.object, get.name, value);
    }                                                  
lox/Parser.java, in assignment()

@Override                                
  public Void visitSetExpr(Expr.Set expr) {
    resolve(expr.value);                   
    resolve(expr.object);                  
    return null;                           
  }                                        

lox/Resolver.java, add after visitLogicalExpr()

@Override                                                            
  public Object visitSetExpr(Expr.Set expr) {                          
    Object object = evaluate(expr.object);

    if (!(object instanceof LoxInstance)) {
      throw new RuntimeError(expr.name, "Only instances have fields.");
    }                                                                  

    Object value = evaluate(expr.value);                               
    ((LoxInstance)object).set(expr.name, value);                       
    return value;                                                      
  }                                                                    
lox/Interpreter.java, add after visitLogicalExpr()




void set(Token name, Object value) {
    fields.put(name.lexeme, value);   
  }                                   
lox/LoxInstance.java, add after get()



define(stmt.name);                                

for (Stmt.Function method : stmt.methods) {       
  FunctionType declaration = FunctionType.METHOD;
  resolveFunction(method, declaration);
}                                                 

return null;                                      
lox/Resolver.java, in visitClassStmt()


NONE,
    FUNCTION,
    METHOD
  }       
lox/Resolver.java, in enum FunctionType, add “,” to previous line




environment.define(stmt.name.lexeme, null);                   

    Map<String, LoxFunction> methods = new HashMap<>();           
    for (Stmt.Function method : stmt.methods) {                   
      LoxFunction function = new LoxFunction(method, environment);
      methods.put(method.name.lexeme, function);                  
    }

    LoxClass klass = new LoxClass(stmt.name.lexeme, methods);     
    environment.assign(stmt.name, klass);                         
lox/Interpreter.java, in visitClassStmt(), replace 1 line



final String name;                                       
  private final Map<String, LoxFunction> methods;

  LoxClass(String name, Map<String, LoxFunction> methods) {
    this.name = name;                                      
    this.methods = methods;                                
  }                                                        

  @Override                                                
  public String toString() {                               
lox/LoxClass.java, in class LoxClass, replace 4 lines



Object get(Token name) {                             
    if (fields.containsKey(name.lexeme)) {             
      return fields.get(name.lexeme);                  
    }                                                  

    LoxFunction method = klass.findMethod(name.lexeme);
    if (method != null) return method;                 

    throw new RuntimeError(name,
        "Undefined property '" + name.lexeme + "'.");  
lox/LoxInstance.java, in get()



LoxFunction findMethod(String name) {
    if (methods.containsKey(name)) {   
      return methods.get(name);        
    }

    return null;                       
  }                                    
lox/LoxClass.java, add after LoxClass()



return new Expr.Literal(previous().literal);    
  }                                                 

  if (match(THIS)) return new Expr.This(previous());

  if (match(IDENTIFIER)) {                          
lox/Parser.java, in primary()



@Override                                  
  public Void visitThisExpr(Expr.This expr) {
    resolveLocal(expr, expr.keyword);        
    return null;                             
  }                                          

lox/Resolver.java, add after visitSetExpr()




define(stmt.name);                         

    beginScope();                              
    scopes.peek().put("this", true);           

    for (Stmt.Function method : stmt.methods) {
lox/Resolver.java, in visitClassStmt()




}           

    endScope();

    return null;
lox/Resolver.java, in visitClassStmt()





LoxFunction method = klass.findMethod(name.lexeme);
    if (method != null) return method.bind(this);      
lox/LoxInstance.java, in get(), replace 1 line



LoxFunction bind(LoxInstance instance) {             
    Environment environment = new Environment(closure);
    environment.define("this", instance);              
    return new LoxFunction(declaration, environment);  
  }                                                    
lox/LoxFunction.java, add after LoxFunction()


@Override                                    
  public Object visitThisExpr(Expr.This expr) {
    return lookUpVariable(expr.keyword, expr);
  }                                            
lox/Interpreter.java, add after visitSetExpr()
